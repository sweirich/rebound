-- |
-- Module       : LinLC
-- Description  : Linear simply typed lambda calculus
-- Stability    : experimental
--
-- A typechecker for a linear lambda calculus. This module demonstrates the
-- usage of the `ScopedState` monad, which can be used when a typing context
-- has to be threaded during typechecking.
module LinLC where

import Control.Monad
import Control.Monad.Except
import Data.Fin
import Data.Vec hiding (bind)
import Rebound hiding (rescope, tail, tabulate)
import Rebound.Bind.Single hiding (rescope)
import Rebound.MonadScoped
import Prelude hiding (tail)

--------------------------------------------------------------------------------
--- Basic definitions
--------------------------------------------------------------------------------

-- | Represent the (current) usage of a variable.
data Usage where
  Unused :: Usage
  Used :: Usage
  deriving (Show, Eq)

-- | Representation of types.
data Ty where
  TyUnit :: Ty
  TyArrow :: Ty -> Ty -> Ty
  deriving (Show, Eq)

-- | Representation of terms.
data Exp (n :: Nat) where
  Var :: Fin n -> Exp n
  CUnit :: Exp n
  Lam :: Bind Exp Exp n -> Exp n
  App :: Exp n -> Exp n -> Exp n
  deriving (Eq, Generic1)

-- Some instances required by rebound. See LC.hs for more explanations.

instance (Eq (Exp n)) => Eq (Bind Exp Exp n) where
  l == r = getBody l == getBody r

instance SubstVar Exp where var = Var

instance Subst Exp Exp where
  isVar (Var x) = Just (Refl, x)
  isVar _ = Nothing

-- | An evaluator for the calculus.
eval :: Exp Z -> Exp Z
eval (Var x) = case x of {}
eval CUnit = CUnit
eval (Lam b) = Lam b
eval (App e1 e2) =
  let v = eval e2
   in case eval e1 of
        Lam b -> eval (instantiate b v)
        t -> App t v

-- Pretty-printing of terms.
instance Show (Exp n) where
  showsPrec :: Int -> Exp n -> String -> String
  showsPrec _ (Var x) = shows x
  showsPrec _ CUnit = showString "()"
  showsPrec d (App e1 e2) =
    showParen True $
      showsPrec 10 e1
        . showString " "
        . showsPrec 11 e2
  showsPrec d (Lam b) =
    showParen True $
      showString "Î». "
        . shows (getBody b)

--------------------------------------------------------------------------------
--- Some helper-constructors
--------------------------------------------------------------------------------

-- | a lambda expression
lam :: Exp (S n) -> Exp n
lam = Lam . bind
-- | an application expression
(@@) :: Exp n -> Exp n -> Exp n
(@@) = App
-- | variable with index 0
v0 :: Exp (S n)
v0 = Var f0
-- | variable with index 1
v1 :: Exp (S (S n))
v1 = Var f1
-- | Notation for the arrow type
(~>) :: Ty -> Ty -> Ty
(~>) = TyArrow
infixr 8 ~>

--------------------------------------------------------------------------------
--- Typechecking infrastructure
--------------------------------------------------------------------------------

-- | A typing environment has to keep track of two things about variables:
-- 1. What their type is (`types`).
-- 2. Whether they've already been used or not (`usages`).
data TCEnv n = TCEnv
  { types :: Vec n Ty,
    usages :: Vec n Usage
  }

-- | The typechecking monad.
--
-- Unlike other calculi, the typing environment is not local. When two
-- subexpressions have to be typechecked, the latter sub-expression has to be
-- typechecked in the environment generated by the former sub-expression. This
-- means that `ScopedReader` cannot be used, as any changes done to the context
-- are local. Hence, the `ScopedState` monad must be used instead.
type TC n a = ScopedStateT TCEnv (Except String) n a

-- | Attempt to "consume" a variable, returning its type. Fails if the variable
-- was already used.
consumeVar :: Fin n -> TC n Ty
consumeVar i = setUsage i >> getsS ((! i) . types)
  where
    -- | Set a variable to `Used`. Fails if the variable was already used.
    setUsage :: Fin n -> TC n ()
    setUsage i = do
      current <- getsS usages
      let (new, old) = set i Used current
      unless (old == Unused) $ throwError "Variable has already been used."
      modifyS $ \s -> s {usages = new}

    -- Vectors have not operations to update a value, so let's implement it.
    set :: Fin n -> t -> Vec n t -> (Vec n t, t)
    set FZ v (h ::: t) = (v ::: t, h)
    set (FS i) v (h ::: t) =
      let (t', v') = set i v t
       in (h ::: t', v')

-- | Add a variable to the scope.
--
-- Since `ScopedState` is threaded rather than passed down using `localS`, we
-- need to provide functions to both enter a new scope, as with `localS`, and to
-- leave it. Additionally, we need to check that variables were used when go out
-- of scope.
addBinder :: Ty -> TC (S n) a -> TC n a
addBinder ty m = rescope enter leave (do v <- m; checkUsed FZ; return v)
  where
    checkUsed :: Fin n -> TC n ()
    checkUsed i = do
      u <- getsS ((! i) . usages)
      unless (u == Used) $ throwError "Variable was not used."

    -- Add the binding in the scope.
    enter :: TCEnv n -> TCEnv (S n)
    enter e = e {types = ty ::: types e, usages = Unused ::: usages e}

    -- And remove it.
    leave :: TCEnv (S n) -> TCEnv n
    leave e = e {types = tail $ types e, usages = tail $ usages e}

-- | Run a computation in the typechecking monad, assuming that all free
-- variables need to be used.
runTC :: (SNatI n) => Vec n Ty -> TC n a -> Either String a
runTC ts m = runExcept $ evalScopedStateT m initEnv
  where
    initEnv = TCEnv {types = ts, usages = tabulate $ const Unused}

--------------------------------------------------------------------------------
--- Bi-directional typechecking
--------------------------------------------------------------------------------

inferType :: Exp n -> TC n Ty
inferType (Var i) = consumeVar i
inferType CUnit = return TyUnit
inferType _ = throwError "Cannot infer type of this construct."

checkType :: Exp n -> Ty -> TC n ()
checkType (Lam bnd) ty = do
  let t = unbindl bnd
  (xTy, tTy) <- ensureArrow ty
  addBinder xTy $ checkType t tTy
  where
    ensureArrow :: Ty -> TC n (Ty, Ty)
    ensureArrow (TyArrow l r) = return (l, r)
    ensureArrow _ = throwError "Type is not arrow."
checkType (App f a) rTy = do
  aTy <- inferType a
  checkType f (TyArrow aTy rTy)
checkType t ty = do
  ty' <- inferType t
  unless (ty == ty') $ throwError "Inferred type does not match expected type."

-- >>> runTC empty $ checkType (lam $ v0) (TyUnit ~> TyUnit)
-- Right ()

-- >>> runTC empty $ checkType (lam $ lam $ v0 @@ v1) (TyUnit ~> (TyUnit ~> TyUnit) ~> TyUnit)
-- Right ()

-- >>> runTC empty $ checkType (lam $ lam $ v1) (TyUnit ~> (TyUnit ~> TyUnit) ~> TyUnit)
-- Left "Variable was not used."

-- >>> runTC empty $ checkType (lam $ lam $ v0) (TyUnit ~> (TyUnit ~> TyUnit) ~> TyUnit)
-- Left "Inferred type does not match expected type."

-- >>> runTC empty $ checkType (lam $ lam $ v0) (TyUnit ~> (TyUnit ~> TyUnit) ~> TyUnit ~> TyUnit)
-- Left "Variable was not used."
